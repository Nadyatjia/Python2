#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#
import codecs
from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def loginWithIdentityCredentialForCertificate(self, identifier, password, keyname, crypto, keepLoggedIn, accessLocation, systemName, identityProvider, certificate):
    """
    Parameters:
     - identifier
     - password
     - keyname
     - crypto
     - keepLoggedIn
     - accessLocation
     - systemName
     - identityProvider
     - certificate
    """
    pass

  def loginWithVerifierForCertificate(self, verifier):
    """
    Parameters:
     - verifier
    """
    pass

  def getRecentMessages(self, messageBoxId, messagesCount):
    """
    Parameters:
     - messageBoxId
     - messagesCount
    """
    pass

  def fetchMessages(self, localTs, count):
    """
    Parameters:
     - localTs
     - count
    """
    pass

  def fetchOperations(self, localRev, count):
    """
    Parameters:
     - localRev
     - count
    """
    pass

  def getLastOpRevision(self):
    pass

  def getProfile(self):
    pass

  def findAndAddContactsByMid(self, reqSeq, mid):
    """
    Parameters:
     - reqSeq
     - mid
    """
    pass

  def findContactByUserid(self, userid):
    """
    Parameters:
     - userid
    """
    pass

  def findAndAddContactsByUserid(self, reqSeq, userid):
    """
    Parameters:
     - reqSeq
     - userid
    """
    pass

  def findContactsByPhone(self, phones):
    """
    Parameters:
     - phones
    """
    pass

  def findAndAddContactsByPhone(self, reqSeq, phones):
    """
    Parameters:
     - reqSeq
     - phones
    """
    pass

  def findContactsByEmail(self, emails):
    """
    Parameters:
     - emails
    """
    pass

  def findAndAddContactsByEmail(self, reqSeq, emails):
    """
    Parameters:
     - reqSeq
     - emails
    """
    pass

  def getContact(self, id):
    """
    Parameters:
     - id
    """
    pass

  def getContacts(self, ids):
    """
    Parameters:
     - ids
    """
    pass

  def getAllContactIds(self):
    pass

  def getBlockedContactIds(self):
    pass

  def blockContact(self, reqSeq, id):
    """
    Parameters:
     - reqSeq
     - id
    """
    pass

  def unblockContact(self, reqSeq, id):
    """
    Parameters:
     - reqSeq
     - id
    """
    pass

  def createRoom(self, reqSeq, contactIds):
    """
    Parameters:
     - reqSeq
     - contactIds
    """
    pass

  def getCompactRoom(self, roomId):
    """
    Parameters:
     - roomId
    """
    pass

  def getRoom(self, roomId):
    """
    Parameters:
     - roomId
    """
    pass

  def inviteIntoRoom(self, reqSeq, roomId, contactIds):
    """
    Parameters:
     - reqSeq
     - roomId
     - contactIds
    """
    pass

  def leaveRoom(self, reqSeq, roomId):
    """
    Parameters:
     - reqSeq
     - roomId
    """
    pass

  def createGroup(self, seq, name, contactIds):
    """
    Parameters:
     - seq
     - name
     - contactIds
    """
    pass

  def getCompactGroup(self, groupId):
    """
    Parameters:
     - groupId
    """
    pass

  def getGroups(self, groupIds):
    """
    Parameters:
     - groupIds
    """
    pass

  def getGroupIdsInvited(self):
    pass

  def getGroupIdsJoined(self):
    pass

  def inviteIntoGroup(self, reqSeq, groupId, contactIds):
    """
    Parameters:
     - reqSeq
     - groupId
     - contactIds
    """
    pass

  def kickoutFromGroup(self, reqSeq, groupId, contactIds):
    """
    Parameters:
     - reqSeq
     - groupId
     - contactIds
    """
    pass

  def acceptGroupInvitation(self, reqSeq, groupId):
    """
    Parameters:
     - reqSeq
     - groupId
    """
    pass

  def cancelGroupInvitation(self, reqSeq, groupId, contactIds):
    """
    Parameters:
     - reqSeq
     - groupId
     - contactIds
    """
    pass

  def leaveGroup(self, reqSeq, groupId):
    """
    Parameters:
     - reqSeq
     - groupId
    """
    pass

  def getMessageBox(self, channelId, messageBoxId, lastMessagesCount):
    """
    Parameters:
     - channelId
     - messageBoxId
     - lastMessagesCount
    """
    pass

  def getMessageBoxList(self, channelId, lastMessagesCount):
    """
    Parameters:
     - channelId
     - lastMessagesCount
    """
    pass

  def getMessageBoxListByStatus(self, channelId, lastMessagesCount, status):
    """
    Parameters:
     - channelId
     - lastMessagesCount
     - status
    """
    pass

  def getMessageBoxCompactWrapUp(self, mid):
    """
    Parameters:
     - mid
    """
    pass

  def getMessageBoxCompactWrapUpList(self, start, messageBoxCount):
    """
    Parameters:
     - start
     - messageBoxCount
    """
    pass

  def sendMessage(self, seq, message):
    """
    Parameters:
     - seq
     - message
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def loginWithIdentityCredentialForCertificate(self, identifier, password, keyname, crypto, keepLoggedIn, accessLocation, systemName, identityProvider, certificate):
    """
    Parameters:
     - identifier
     - password
     - keyname
     - crypto
     - keepLoggedIn
     - accessLocation
     - systemName
     - identityProvider
     - certificate
    """
    self.send_loginWithIdentityCredentialForCertificate(identifier, password, keyname, crypto, keepLoggedIn, accessLocation, systemName, identityProvider, certificate)
    return self.recv_loginWithIdentityCredentialForCertificate()

  def send_loginWithIdentityCredentialForCertificate(self, identifier, password, keyname, crypto, keepLoggedIn, accessLocation, systemName, identityProvider, certificate):
    self._oprot.writeMessageBegin('loginWithIdentityCredentialForCertificate', TMessageType.CALL, self._seqid)
    args = loginWithIdentityCredentialForCertificate_args()
    args.identifier = identifier
    args.password = password
    args.keyname = keyname
    args.crypto = crypto
    args.keepLoggedIn = keepLoggedIn
    args.accessLocation = accessLocation
    args.systemName = systemName
    args.identityProvider = identityProvider
    args.certificate = certificate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_loginWithIdentityCredentialForCertificate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = loginWithIdentityCredentialForCertificate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "loginWithIdentityCredentialForCertificate failed: unknown result");

  def loginWithVerifierForCertificate(self, verifier):
    """
    Parameters:
     - verifier
    """
    self.send_loginWithVerifierForCertificate(verifier)
    return self.recv_loginWithVerifierForCertificate()

  def send_loginWithVerifierForCertificate(self, verifier):
    self._oprot.writeMessageBegin('loginWithVerifierForCertificate', TMessageType.CALL, self._seqid)
    args = loginWithVerifierForCertificate_args()
    args.verifier = verifier
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_loginWithVerifierForCertificate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = loginWithVerifierForCertificate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "loginWithVerifierForCertificate failed: unknown result");

  def getRecentMessages(self, messageBoxId, messagesCount):
    """
    Parameters:
     - messageBoxId
     - messagesCount
    """
    self.send_getRecentMessages(messageBoxId, messagesCount)
    return self.recv_getRecentMessages()

  def send_getRecentMessages(self, messageBoxId, messagesCount):
    self._oprot.writeMessageBegin('getRecentMessages', TMessageType.CALL, self._seqid)
    args = getRecentMessages_args()
    args.messageBoxId = messageBoxId
    args.messagesCount = messagesCount
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecentMessages(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecentMessages_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecentMessages failed: unknown result");

  def fetchMessages(self, localTs, count):
    """
    Parameters:
     - localTs
     - count
    """
    self.send_fetchMessages(localTs, count)
    return self.recv_fetchMessages()

  def send_fetchMessages(self, localTs, count):
    self._oprot.writeMessageBegin('fetchMessages', TMessageType.CALL, self._seqid)
    args = fetchMessages_args()
    args.localTs = localTs
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fetchMessages(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = fetchMessages_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fetchMessages failed: unknown result");

  def fetchOperations(self, localRev, count):
    """
    Parameters:
     - localRev
     - count
    """
    self.send_fetchOperations(localRev, count)
    return self.recv_fetchOperations()

  def send_fetchOperations(self, localRev, count):
    self._oprot.writeMessageBegin('fetchOperations', TMessageType.CALL, self._seqid)
    args = fetchOperations_args()
    args.localRev = localRev
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fetchOperations(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = fetchOperations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fetchOperations failed: unknown result");

  def getLastOpRevision(self):
    self.send_getLastOpRevision()
    return self.recv_getLastOpRevision()

  def send_getLastOpRevision(self):
    self._oprot.writeMessageBegin('getLastOpRevision', TMessageType.CALL, self._seqid)
    args = getLastOpRevision_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLastOpRevision(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLastOpRevision_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLastOpRevision failed: unknown result");

  def getProfile(self):
    self.send_getProfile()
    return self.recv_getProfile()

  def send_getProfile(self):
    self._oprot.writeMessageBegin('getProfile', TMessageType.CALL, self._seqid)
    args = getProfile_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getProfile(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getProfile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getProfile failed: unknown result");

  def findAndAddContactsByMid(self, reqSeq, mid):
    """
    Parameters:
     - reqSeq
     - mid
    """
    self.send_findAndAddContactsByMid(reqSeq, mid)
    return self.recv_findAndAddContactsByMid()

  def send_findAndAddContactsByMid(self, reqSeq, mid):
    self._oprot.writeMessageBegin('findAndAddContactsByMid', TMessageType.CALL, self._seqid)
    args = findAndAddContactsByMid_args()
    args.reqSeq = reqSeq
    args.mid = mid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findAndAddContactsByMid(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findAndAddContactsByMid_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findAndAddContactsByMid failed: unknown result");

  def findContactByUserid(self, userid):
    """
    Parameters:
     - userid
    """
    self.send_findContactByUserid(userid)
    return self.recv_findContactByUserid()

  def send_findContactByUserid(self, userid):
    self._oprot.writeMessageBegin('findContactByUserid', TMessageType.CALL, self._seqid)
    args = findContactByUserid_args()
    args.userid = userid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findContactByUserid(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findContactByUserid_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findContactByUserid failed: unknown result");

  def findAndAddContactsByUserid(self, reqSeq, userid):
    """
    Parameters:
     - reqSeq
     - userid
    """
    self.send_findAndAddContactsByUserid(reqSeq, userid)
    return self.recv_findAndAddContactsByUserid()

  def send_findAndAddContactsByUserid(self, reqSeq, userid):
    self._oprot.writeMessageBegin('findAndAddContactsByUserid', TMessageType.CALL, self._seqid)
    args = findAndAddContactsByUserid_args()
    args.reqSeq = reqSeq
    args.userid = userid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findAndAddContactsByUserid(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findAndAddContactsByUserid_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findAndAddContactsByUserid failed: unknown result");

  def findContactsByPhone(self, phones):
    """
    Parameters:
     - phones
    """
    self.send_findContactsByPhone(phones)
    return self.recv_findContactsByPhone()

  def send_findContactsByPhone(self, phones):
    self._oprot.writeMessageBegin('findContactsByPhone', TMessageType.CALL, self._seqid)
    args = findContactsByPhone_args()
    args.phones = phones
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findContactsByPhone(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findContactsByPhone_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findContactsByPhone failed: unknown result");

  def findAndAddContactsByPhone(self, reqSeq, phones):
    """
    Parameters:
     - reqSeq
     - phones
    """
    self.send_findAndAddContactsByPhone(reqSeq, phones)
    return self.recv_findAndAddContactsByPhone()

  def send_findAndAddContactsByPhone(self, reqSeq, phones):
    self._oprot.writeMessageBegin('findAndAddContactsByPhone', TMessageType.CALL, self._seqid)
    args = findAndAddContactsByPhone_args()
    args.reqSeq = reqSeq
    args.phones = phones
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findAndAddContactsByPhone(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findAndAddContactsByPhone_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findAndAddContactsByPhone failed: unknown result");

  def findContactsByEmail(self, emails):
    """
    Parameters:
     - emails
    """
    self.send_findContactsByEmail(emails)
    return self.recv_findContactsByEmail()

  def send_findContactsByEmail(self, emails):
    self._oprot.writeMessageBegin('findContactsByEmail', TMessageType.CALL, self._seqid)
    args = findContactsByEmail_args()
    args.emails = emails
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findContactsByEmail(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findContactsByEmail_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findContactsByEmail failed: unknown result");

  def findAndAddContactsByEmail(self, reqSeq, emails):
    """
    Parameters:
     - reqSeq
     - emails
    """
    self.send_findAndAddContactsByEmail(reqSeq, emails)
    return self.recv_findAndAddContactsByEmail()

  def send_findAndAddContactsByEmail(self, reqSeq, emails):
    self._oprot.writeMessageBegin('findAndAddContactsByEmail', TMessageType.CALL, self._seqid)
    args = findAndAddContactsByEmail_args()
    args.reqSeq = reqSeq
    args.emails = emails
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findAndAddContactsByEmail(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findAndAddContactsByEmail_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findAndAddContactsByEmail failed: unknown result");

  def getContact(self, id):
    """
    Parameters:
     - id
    """
    self.send_getContact(id)
    return self.recv_getContact()

  def send_getContact(self, id):
    self._oprot.writeMessageBegin('getContact', TMessageType.CALL, self._seqid)
    args = getContact_args()
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getContact(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getContact_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getContact failed: unknown result");

  def getContacts(self, ids):
    """
    Parameters:
     - ids
    """
    self.send_getContacts(ids)
    return self.recv_getContacts()

  def send_getContacts(self, ids):
    self._oprot.writeMessageBegin('getContacts', TMessageType.CALL, self._seqid)
    args = getContacts_args()
    args.ids = ids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getContacts(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getContacts_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getContacts failed: unknown result");

  def getAllContactIds(self):
    self.send_getAllContactIds()
    return self.recv_getAllContactIds()

  def send_getAllContactIds(self):
    self._oprot.writeMessageBegin('getAllContactIds', TMessageType.CALL, self._seqid)
    args = getAllContactIds_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllContactIds(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllContactIds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllContactIds failed: unknown result");

  def getBlockedContactIds(self):
    self.send_getBlockedContactIds()
    return self.recv_getBlockedContactIds()

  def send_getBlockedContactIds(self):
    self._oprot.writeMessageBegin('getBlockedContactIds', TMessageType.CALL, self._seqid)
    args = getBlockedContactIds_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBlockedContactIds(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBlockedContactIds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBlockedContactIds failed: unknown result");

  def blockContact(self, reqSeq, id):
    """
    Parameters:
     - reqSeq
     - id
    """
    self.send_blockContact(reqSeq, id)
    self.recv_blockContact()

  def send_blockContact(self, reqSeq, id):
    self._oprot.writeMessageBegin('blockContact', TMessageType.CALL, self._seqid)
    args = blockContact_args()
    args.reqSeq = reqSeq
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_blockContact(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = blockContact_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def unblockContact(self, reqSeq, id):
    """
    Parameters:
     - reqSeq
     - id
    """
    self.send_unblockContact(reqSeq, id)
    self.recv_unblockContact()

  def send_unblockContact(self, reqSeq, id):
    self._oprot.writeMessageBegin('unblockContact', TMessageType.CALL, self._seqid)
    args = unblockContact_args()
    args.reqSeq = reqSeq
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unblockContact(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unblockContact_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def createRoom(self, reqSeq, contactIds):
    """
    Parameters:
     - reqSeq
     - contactIds
    """
    self.send_createRoom(reqSeq, contactIds)
    return self.recv_createRoom()

  def send_createRoom(self, reqSeq, contactIds):
    self._oprot.writeMessageBegin('createRoom', TMessageType.CALL, self._seqid)
    args = createRoom_args()
    args.reqSeq = reqSeq
    args.contactIds = contactIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createRoom(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createRoom failed: unknown result");

  def getCompactRoom(self, roomId):
    """
    Parameters:
     - roomId
    """
    self.send_getCompactRoom(roomId)
    return self.recv_getCompactRoom()

  def send_getCompactRoom(self, roomId):
    self._oprot.writeMessageBegin('getCompactRoom', TMessageType.CALL, self._seqid)
    args = getCompactRoom_args()
    args.roomId = roomId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCompactRoom(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCompactRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCompactRoom failed: unknown result");

  def getRoom(self, roomId):
    """
    Parameters:
     - roomId
    """
    self.send_getRoom(roomId)
    return self.recv_getRoom()

  def send_getRoom(self, roomId):
    self._oprot.writeMessageBegin('getRoom', TMessageType.CALL, self._seqid)
    args = getRoom_args()
    args.roomId = roomId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRoom(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRoom failed: unknown result");

  def inviteIntoRoom(self, reqSeq, roomId, contactIds):
    """
    Parameters:
     - reqSeq
     - roomId
     - contactIds
    """
    self.send_inviteIntoRoom(reqSeq, roomId, contactIds)
    self.recv_inviteIntoRoom()

  def send_inviteIntoRoom(self, reqSeq, roomId, contactIds):
    self._oprot.writeMessageBegin('inviteIntoRoom', TMessageType.CALL, self._seqid)
    args = inviteIntoRoom_args()
    args.reqSeq = reqSeq
    args.roomId = roomId
    args.contactIds = contactIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inviteIntoRoom(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = inviteIntoRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def leaveRoom(self, reqSeq, roomId):
    """
    Parameters:
     - reqSeq
     - roomId
    """
    self.send_leaveRoom(reqSeq, roomId)
    self.recv_leaveRoom()

  def send_leaveRoom(self, reqSeq, roomId):
    self._oprot.writeMessageBegin('leaveRoom', TMessageType.CALL, self._seqid)
    args = leaveRoom_args()
    args.reqSeq = reqSeq
    args.roomId = roomId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_leaveRoom(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = leaveRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def createGroup(self, seq, name, contactIds):
    """
    Parameters:
     - seq
     - name
     - contactIds
    """
    self.send_createGroup(seq, name, contactIds)
    return self.recv_createGroup()

  def send_createGroup(self, seq, name, contactIds):
    self._oprot.writeMessageBegin('createGroup', TMessageType.CALL, self._seqid)
    args = createGroup_args()
    args.seq = seq
    args.name = name
    args.contactIds = contactIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createGroup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createGroup failed: unknown result");

  def getCompactGroup(self, groupId):
    """
    Parameters:
     - groupId
    """
    self.send_getCompactGroup(groupId)
    return self.recv_getCompactGroup()

  def send_getCompactGroup(self, groupId):
    self._oprot.writeMessageBegin('getCompactGroup', TMessageType.CALL, self._seqid)
    args = getCompactGroup_args()
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCompactGroup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCompactGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCompactGroup failed: unknown result");

  def getGroups(self, groupIds):
    """
    Parameters:
     - groupIds
    """
    self.send_getGroups(groupIds)
    return self.recv_getGroups()

  def send_getGroups(self, groupIds):
    self._oprot.writeMessageBegin('getGroups', TMessageType.CALL, self._seqid)
    args = getGroups_args()
    args.groupIds = groupIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroups(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroups failed: unknown result");

  def getGroupIdsInvited(self):
    self.send_getGroupIdsInvited()
    return self.recv_getGroupIdsInvited()

  def send_getGroupIdsInvited(self):
    self._oprot.writeMessageBegin('getGroupIdsInvited', TMessageType.CALL, self._seqid)
    args = getGroupIdsInvited_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupIdsInvited(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGroupIdsInvited_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupIdsInvited failed: unknown result");

  def getGroupIdsJoined(self):
    self.send_getGroupIdsJoined()
    return self.recv_getGroupIdsJoined()

  def send_getGroupIdsJoined(self):
    self._oprot.writeMessageBegin('getGroupIdsJoined', TMessageType.CALL, self._seqid)
    args = getGroupIdsJoined_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupIdsJoined(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGroupIdsJoined_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupIdsJoined failed: unknown result");

  def inviteIntoGroup(self, reqSeq, groupId, contactIds):
    """
    Parameters:
     - reqSeq
     - groupId
     - contactIds
    """
    self.send_inviteIntoGroup(reqSeq, groupId, contactIds)
    self.recv_inviteIntoGroup()

  def send_inviteIntoGroup(self, reqSeq, groupId, contactIds):
    self._oprot.writeMessageBegin('inviteIntoGroup', TMessageType.CALL, self._seqid)
    args = inviteIntoGroup_args()
    args.reqSeq = reqSeq
    args.groupId = groupId
    args.contactIds = contactIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inviteIntoGroup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = inviteIntoGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def kickoutFromGroup(self, reqSeq, groupId, contactIds):
    """
    Parameters:
     - reqSeq
     - groupId
     - contactIds
    """
    self.send_kickoutFromGroup(reqSeq, groupId, contactIds)
    self.recv_kickoutFromGroup()

  def send_kickoutFromGroup(self, reqSeq, groupId, contactIds):
    self._oprot.writeMessageBegin('kickoutFromGroup', TMessageType.CALL, self._seqid)
    args = kickoutFromGroup_args()
    args.reqSeq = reqSeq
    args.groupId = groupId
    args.contactIds = contactIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_kickoutFromGroup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = kickoutFromGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def acceptGroupInvitation(self, reqSeq, groupId):
    """
    Parameters:
     - reqSeq
     - groupId
    """
    self.send_acceptGroupInvitation(reqSeq, groupId)
    self.recv_acceptGroupInvitation()

  def send_acceptGroupInvitation(self, reqSeq, groupId):
    self._oprot.writeMessageBegin('acceptGroupInvitation', TMessageType.CALL, self._seqid)
    args = acceptGroupInvitation_args()
    args.reqSeq = reqSeq
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acceptGroupInvitation(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = acceptGroupInvitation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def cancelGroupInvitation(self, reqSeq, groupId, contactIds):
    """
    Parameters:
     - reqSeq
     - groupId
     - contactIds
    """
    self.send_cancelGroupInvitation(reqSeq, groupId, contactIds)
    self.recv_cancelGroupInvitation()

  def send_cancelGroupInvitation(self, reqSeq, groupId, contactIds):
    self._oprot.writeMessageBegin('cancelGroupInvitation', TMessageType.CALL, self._seqid)
    args = cancelGroupInvitation_args()
    args.reqSeq = reqSeq
    args.groupId = groupId
    args.contactIds = contactIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancelGroupInvitation(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cancelGroupInvitation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def leaveGroup(self, reqSeq, groupId):
    """
    Parameters:
     - reqSeq
     - groupId
    """
    self.send_leaveGroup(reqSeq, groupId)
    self.recv_leaveGroup()

  def send_leaveGroup(self, reqSeq, groupId):
    self._oprot.writeMessageBegin('leaveGroup', TMessageType.CALL, self._seqid)
    args = leaveGroup_args()
    args.reqSeq = reqSeq
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_leaveGroup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = leaveGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e is not None:
      raise result.e
    return

  def getMessageBox(self, channelId, messageBoxId, lastMessagesCount):
    """
    Parameters:
     - channelId
     - messageBoxId
     - lastMessagesCount
    """
    self.send_getMessageBox(channelId, messageBoxId, lastMessagesCount)
    return self.recv_getMessageBox()

  def send_getMessageBox(self, channelId, messageBoxId, lastMessagesCount):
    self._oprot.writeMessageBegin('getMessageBox', TMessageType.CALL, self._seqid)
    args = getMessageBox_args()
    args.channelId = channelId
    args.messageBoxId = messageBoxId
    args.lastMessagesCount = lastMessagesCount
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMessageBox(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMessageBox_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMessageBox failed: unknown result");

  def getMessageBoxList(self, channelId, lastMessagesCount):
    """
    Parameters:
     - channelId
     - lastMessagesCount
    """
    self.send_getMessageBoxList(channelId, lastMessagesCount)
    return self.recv_getMessageBoxList()

  def send_getMessageBoxList(self, channelId, lastMessagesCount):
    self._oprot.writeMessageBegin('getMessageBoxList', TMessageType.CALL, self._seqid)
    args = getMessageBoxList_args()
    args.channelId = channelId
    args.lastMessagesCount = lastMessagesCount
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMessageBoxList(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMessageBoxList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMessageBoxList failed: unknown result");

  def getMessageBoxListByStatus(self, channelId, lastMessagesCount, status):
    """
    Parameters:
     - channelId
     - lastMessagesCount
     - status
    """
    self.send_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
    return self.recv_getMessageBoxListByStatus()

  def send_getMessageBoxListByStatus(self, channelId, lastMessagesCount, status):
    self._oprot.writeMessageBegin('getMessageBoxListByStatus', TMessageType.CALL, self._seqid)
    args = getMessageBoxListByStatus_args()
    args.channelId = channelId
    args.lastMessagesCount = lastMessagesCount
    args.status = status
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMessageBoxListByStatus(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMessageBoxListByStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMessageBoxListByStatus failed: unknown result");

  def getMessageBoxCompactWrapUp(self, mid):
    """
    Parameters:
     - mid
    """
    self.send_getMessageBoxCompactWrapUp(mid)
    return self.recv_getMessageBoxCompactWrapUp()

  def send_getMessageBoxCompactWrapUp(self, mid):
    self._oprot.writeMessageBegin('getMessageBoxCompactWrapUp', TMessageType.CALL, self._seqid)
    args = getMessageBoxCompactWrapUp_args()
    args.mid = mid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMessageBoxCompactWrapUp(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMessageBoxCompactWrapUp_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMessageBoxCompactWrapUp failed: unknown result");

  def getMessageBoxCompactWrapUpList(self, start, messageBoxCount):
    """
    Parameters:
     - start
     - messageBoxCount
    """
    self.send_getMessageBoxCompactWrapUpList(start, messageBoxCount)
    return self.recv_getMessageBoxCompactWrapUpList()

  def send_getMessageBoxCompactWrapUpList(self, start, messageBoxCount):
    self._oprot.writeMessageBegin('getMessageBoxCompactWrapUpList', TMessageType.CALL, self._seqid)
    args = getMessageBoxCompactWrapUpList_args()
    args.start = start
    args.messageBoxCount = messageBoxCount
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMessageBoxCompactWrapUpList(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMessageBoxCompactWrapUpList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMessageBoxCompactWrapUpList failed: unknown result");

  def sendMessage(self, seq, message):
    """
    Parameters:
     - seq
     - message
    """
    self.send_sendMessage(seq, message)
    return self.recv_sendMessage()

  def send_sendMessage(self, seq, message):
    self._oprot.writeMessageBegin('sendMessage', TMessageType.CALL, self._seqid)
    args = sendMessage_args()
    args.seq = seq
    args.message = message
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendMessage(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendMessage_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendMessage failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["loginWithIdentityCredentialForCertificate"] = Processor.process_loginWithIdentityCredentialForCertificate
    self._processMap["loginWithVerifierForCertificate"] = Processor.process_loginWithVerifierForCertificate
    self._processMap["getRecentMessages"] = Processor.process_getRecentMessages
    self._processMap["fetchMessages"] = Processor.process_fetchMessages
    self._processMap["fetchOperations"] = Processor.process_fetchOperations
    self._processMap["getLastOpRevision"] = Processor.process_getLastOpRevision
    self._processMap["getProfile"] = Processor.process_getProfile
    self._processMap["findAndAddContactsByMid"] = Processor.process_findAndAddContactsByMid
    self._processMap["findContactByUserid"] = Processor.process_findContactByUserid
    self._processMap["findAndAddContactsByUserid"] = Processor.process_findAndAddContactsByUserid
    self._processMap["findContactsByPhone"] = Processor.process_findContactsByPhone
    self._processMap["findAndAddContactsByPhone"] = Processor.process_findAndAddContactsByPhone
    self._processMap["findContactsByEmail"] = Processor.process_findContactsByEmail
    self._processMap["findAndAddContactsByEmail"] = Processor.process_findAndAddContactsByEmail
    self._processMap["getContact"] = Processor.process_getContact
    self._processMap["getContacts"] = Processor.process_getContacts
    self._processMap["getAllContactIds"] = Processor.process_getAllContactIds
    self._processMap["getBlockedContactIds"] = Processor.process_getBlockedContactIds
    self._processMap["blockContact"] = Processor.process_blockContact
    self._processMap["unblockContact"] = Processor.process_unblockContact
    self._processMap["createRoom"] = Processor.process_createRoom
    self._processMap["getCompactRoom"] = Processor.process_getCompactRoom
    self._processMap["getRoom"] = Processor.process_getRoom
    self._processMap["inviteIntoRoom"] = Processor.process_inviteIntoRoom
    self._processMap["leaveRoom"] = Processor.process_leaveRoom
    self._processMap["createGroup"] = Processor.process_createGroup
    self._processMap["getCompactGroup"] = Processor.process_getCompactGroup
    self._processMap["getGroups"] = Processor.process_getGroups
    self._processMap["getGroupIdsInvited"] = Processor.process_getGroupIdsInvited
    self._processMap["getGroupIdsJoined"] = Processor.process_getGroupIdsJoined
    self._processMap["inviteIntoGroup"] = Processor.process_inviteIntoGroup
    self._processMap["kickoutFromGroup"] = Processor.process_kickoutFromGroup
    self._processMap["acceptGroupInvitation"] = Processor.process_acceptGroupInvitation
    self._processMap["cancelGroupInvitation"] = Processor.process_cancelGroupInvitation
    self._processMap["leaveGroup"] = Processor.process_leaveGroup
    self._processMap["getMessageBox"] = Processor.process_getMessageBox
    self._processMap["getMessageBoxList"] = Processor.process_getMessageBoxList
    self._processMap["getMessageBoxListByStatus"] = Processor.process_getMessageBoxListByStatus
    self._processMap["getMessageBoxCompactWrapUp"] = Processor.process_getMessageBoxCompactWrapUp
    self._processMap["getMessageBoxCompactWrapUpList"] = Processor.process_getMessageBoxCompactWrapUpList
    self._processMap["sendMessage"] = Processor.process_sendMessage

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_loginWithIdentityCredentialForCertificate(self, seqid, iprot, oprot):
    args = loginWithIdentityCredentialForCertificate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = loginWithIdentityCredentialForCertificate_result()
    try:
      result.success = self._handler.loginWithIdentityCredentialForCertificate(args.identifier, args.password, args.keyname, args.crypto, args.keepLoggedIn, args.accessLocation, args.systemName, args.identityProvider, args.certificate)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("loginWithIdentityCredentialForCertificate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_loginWithVerifierForCertificate(self, seqid, iprot, oprot):
    args = loginWithVerifierForCertificate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = loginWithVerifierForCertificate_result()
    result.success = self._handler.loginWithVerifierForCertificate(args.verifier)
    oprot.writeMessageBegin("loginWithVerifierForCertificate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecentMessages(self, seqid, iprot, oprot):
    args = getRecentMessages_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecentMessages_result()
    try:
      result.success = self._handler.getRecentMessages(args.messageBoxId, args.messagesCount)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getRecentMessages", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fetchMessages(self, seqid, iprot, oprot):
    args = fetchMessages_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fetchMessages_result()
    try:
      result.success = self._handler.fetchMessages(args.localTs, args.count)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("fetchMessages", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fetchOperations(self, seqid, iprot, oprot):
    args = fetchOperations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fetchOperations_result()
    try:
      result.success = self._handler.fetchOperations(args.localRev, args.count)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("fetchOperations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLastOpRevision(self, seqid, iprot, oprot):
    args = getLastOpRevision_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLastOpRevision_result()
    try:
      result.success = self._handler.getLastOpRevision()
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getLastOpRevision", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getProfile(self, seqid, iprot, oprot):
    args = getProfile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getProfile_result()
    try:
      result.success = self._handler.getProfile()
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getProfile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findAndAddContactsByMid(self, seqid, iprot, oprot):
    args = findAndAddContactsByMid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findAndAddContactsByMid_result()
    try:
      result.success = self._handler.findAndAddContactsByMid(args.reqSeq, args.mid)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findAndAddContactsByMid", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findContactByUserid(self, seqid, iprot, oprot):
    args = findContactByUserid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findContactByUserid_result()
    try:
      result.success = self._handler.findContactByUserid(args.userid)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findContactByUserid", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findAndAddContactsByUserid(self, seqid, iprot, oprot):
    args = findAndAddContactsByUserid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findAndAddContactsByUserid_result()
    try:
      result.success = self._handler.findAndAddContactsByUserid(args.reqSeq, args.userid)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findAndAddContactsByUserid", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findContactsByPhone(self, seqid, iprot, oprot):
    args = findContactsByPhone_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findContactsByPhone_result()
    try:
      result.success = self._handler.findContactsByPhone(args.phones)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findContactsByPhone", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findAndAddContactsByPhone(self, seqid, iprot, oprot):
    args = findAndAddContactsByPhone_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findAndAddContactsByPhone_result()
    try:
      result.success = self._handler.findAndAddContactsByPhone(args.reqSeq, args.phones)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findAndAddContactsByPhone", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findContactsByEmail(self, seqid, iprot, oprot):
    args = findContactsByEmail_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findContactsByEmail_result()
    try:
      result.success = self._handler.findContactsByEmail(args.emails)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findContactsByEmail", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findAndAddContactsByEmail(self, seqid, iprot, oprot):
    args = findAndAddContactsByEmail_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findAndAddContactsByEmail_result()
    try:
      result.success = self._handler.findAndAddContactsByEmail(args.reqSeq, args.emails)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("findAndAddContactsByEmail", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getContact(self, seqid, iprot, oprot):
    args = getContact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getContact_result()
    try:
      result.success = self._handler.getContact(args.id)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getContact", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getContacts(self, seqid, iprot, oprot):
    args = getContacts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getContacts_result()
    try:
      result.success = self._handler.getContacts(args.ids)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getContacts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllContactIds(self, seqid, iprot, oprot):
    args = getAllContactIds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllContactIds_result()
    try:
      result.success = self._handler.getAllContactIds()
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getAllContactIds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBlockedContactIds(self, seqid, iprot, oprot):
    args = getBlockedContactIds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBlockedContactIds_result()
    try:
      result.success = self._handler.getBlockedContactIds()
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getBlockedContactIds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_blockContact(self, seqid, iprot, oprot):
    args = blockContact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = blockContact_result()
    try:
      self._handler.blockContact(args.reqSeq, args.id)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("blockContact", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unblockContact(self, seqid, iprot, oprot):
    args = unblockContact_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unblockContact_result()
    try:
      self._handler.unblockContact(args.reqSeq, args.id)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("unblockContact", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createRoom(self, seqid, iprot, oprot):
    args = createRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createRoom_result()
    try:
      result.success = self._handler.createRoom(args.reqSeq, args.contactIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("createRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCompactRoom(self, seqid, iprot, oprot):
    args = getCompactRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCompactRoom_result()
    try:
      result.success = self._handler.getCompactRoom(args.roomId)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getCompactRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRoom(self, seqid, iprot, oprot):
    args = getRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRoom_result()
    try:
      result.success = self._handler.getRoom(args.roomId)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inviteIntoRoom(self, seqid, iprot, oprot):
    args = inviteIntoRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inviteIntoRoom_result()
    try:
      self._handler.inviteIntoRoom(args.reqSeq, args.roomId, args.contactIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("inviteIntoRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_leaveRoom(self, seqid, iprot, oprot):
    args = leaveRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = leaveRoom_result()
    try:
      self._handler.leaveRoom(args.reqSeq, args.roomId)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("leaveRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createGroup(self, seqid, iprot, oprot):
    args = createGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createGroup_result()
    try:
      result.success = self._handler.createGroup(args.seq, args.name, args.contactIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("createGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCompactGroup(self, seqid, iprot, oprot):
    args = getCompactGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCompactGroup_result()
    try:
      result.success = self._handler.getCompactGroup(args.groupId)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getCompactGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroups(self, seqid, iprot, oprot):
    args = getGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroups_result()
    try:
      result.success = self._handler.getGroups(args.groupIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupIdsInvited(self, seqid, iprot, oprot):
    args = getGroupIdsInvited_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupIdsInvited_result()
    try:
      result.success = self._handler.getGroupIdsInvited()
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getGroupIdsInvited", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupIdsJoined(self, seqid, iprot, oprot):
    args = getGroupIdsJoined_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupIdsJoined_result()
    try:
      result.success = self._handler.getGroupIdsJoined()
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getGroupIdsJoined", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inviteIntoGroup(self, seqid, iprot, oprot):
    args = inviteIntoGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inviteIntoGroup_result()
    try:
      self._handler.inviteIntoGroup(args.reqSeq, args.groupId, args.contactIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("inviteIntoGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_kickoutFromGroup(self, seqid, iprot, oprot):
    args = kickoutFromGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = kickoutFromGroup_result()
    try:
      self._handler.kickoutFromGroup(args.reqSeq, args.groupId, args.contactIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("kickoutFromGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acceptGroupInvitation(self, seqid, iprot, oprot):
    args = acceptGroupInvitation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acceptGroupInvitation_result()
    try:
      self._handler.acceptGroupInvitation(args.reqSeq, args.groupId)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("acceptGroupInvitation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancelGroupInvitation(self, seqid, iprot, oprot):
    args = cancelGroupInvitation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancelGroupInvitation_result()
    try:
      self._handler.cancelGroupInvitation(args.reqSeq, args.groupId, args.contactIds)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("cancelGroupInvitation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_leaveGroup(self, seqid, iprot, oprot):
    args = leaveGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = leaveGroup_result()
    try:
      self._handler.leaveGroup(args.reqSeq, args.groupId)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("leaveGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMessageBox(self, seqid, iprot, oprot):
    args = getMessageBox_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMessageBox_result()
    try:
      result.success = self._handler.getMessageBox(args.channelId, args.messageBoxId, args.lastMessagesCount)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getMessageBox", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMessageBoxList(self, seqid, iprot, oprot):
    args = getMessageBoxList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMessageBoxList_result()
    try:
      result.success = self._handler.getMessageBoxList(args.channelId, args.lastMessagesCount)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getMessageBoxList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMessageBoxListByStatus(self, seqid, iprot, oprot):
    args = getMessageBoxListByStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMessageBoxListByStatus_result()
    try:
      result.success = self._handler.getMessageBoxListByStatus(args.channelId, args.lastMessagesCount, args.status)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getMessageBoxListByStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMessageBoxCompactWrapUp(self, seqid, iprot, oprot):
    args = getMessageBoxCompactWrapUp_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMessageBoxCompactWrapUp_result()
    try:
      result.success = self._handler.getMessageBoxCompactWrapUp(args.mid)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getMessageBoxCompactWrapUp", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMessageBoxCompactWrapUpList(self, seqid, iprot, oprot):
    args = getMessageBoxCompactWrapUpList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMessageBoxCompactWrapUpList_result()
    try:
      result.success = self._handler.getMessageBoxCompactWrapUpList(args.start, args.messageBoxCount)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("getMessageBoxCompactWrapUpList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendMessage(self, seqid, iprot, oprot):
    args = sendMessage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendMessage_result()
    try:
      result.success = self._handler.sendMessage(args.seq, args.message)
    except TalkException:
      result.e = e
    oprot.writeMessageBegin("sendMessage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class loginWithIdentityCredentialForCertificate_args(object):
  """
  Attributes:
   - identifier
   - password
   - keyname
   - crypto
   - keepLoggedIn
   - accessLocation
   - systemName
   - identityProvider
   - certificate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'identifier', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'keyname', None, None, ), # 3
    (4, TType.STRING, 'crypto', None, None, ), # 4
    (5, TType.BOOL, 'keepLoggedIn', None, None, ), # 5
    (6, TType.STRING, 'accessLocation', None, None, ), # 6
    (7, TType.STRING, 'systemName', None, None, ), # 7
    (8, TType.I32, 'identityProvider', None, None, ), # 8
    (9, TType.STRING, 'certificate', None, None, ), # 9
  )

  def __init__(self, identifier=None, password=None, keyname=None, crypto=None, keepLoggedIn=None, accessLocation=None, systemName=None, identityProvider=None, certificate=None,):
    self.identifier = identifier
    self.password = password
    self.keyname = keyname
    self.crypto = crypto
    self.keepLoggedIn = keepLoggedIn
    self.accessLocation = accessLocation
    self.systemName = systemName
    self.identityProvider = identityProvider
    self.certificate = certificate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.identifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.keyname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.crypto = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.keepLoggedIn = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.accessLocation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.systemName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.identityProvider = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.certificate = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loginWithIdentityCredentialForCertificate_args')
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.STRING, 1)
      oprot.writeString(self.identifier)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.keyname is not None:
      oprot.writeFieldBegin('keyname', TType.STRING, 3)
      oprot.writeString(self.keyname)
      oprot.writeFieldEnd()
    if self.crypto is not None:
      oprot.writeFieldBegin('crypto', TType.STRING, 4)
      oprot.writeString(self.crypto)
      oprot.writeFieldEnd()
    if self.keepLoggedIn is not None:
      oprot.writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
      oprot.writeBool(self.keepLoggedIn)
      oprot.writeFieldEnd()
    if self.accessLocation is not None:
      oprot.writeFieldBegin('accessLocation', TType.STRING, 6)
      oprot.writeString(self.accessLocation)
      oprot.writeFieldEnd()
    if self.systemName is not None:
      oprot.writeFieldBegin('systemName', TType.STRING, 7)
      oprot.writeString(self.systemName)
      oprot.writeFieldEnd()
    if self.identityProvider is not None:
      oprot.writeFieldBegin('identityProvider', TType.I32, 8)
      oprot.writeI32(self.identityProvider)
      oprot.writeFieldEnd()
    if self.certificate is not None:
      oprot.writeFieldBegin('certificate', TType.STRING, 9)
      oprot.writeString(self.certificate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class loginWithIdentityCredentialForCertificate_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LoginResult, LoginResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LoginResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loginWithIdentityCredentialForCertificate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class loginWithVerifierForCertificate_args(object):
  """
  Attributes:
   - verifier
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.STRING, 'verifier', None, None, ), # 3
  )

  def __init__(self, verifier=None,):
    self.verifier = verifier

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.STRING:
          self.verifier = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loginWithVerifierForCertificate_args')
    if self.verifier is not None:
      oprot.writeFieldBegin('verifier', TType.STRING, 3)
      oprot.writeString(self.verifier)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class loginWithVerifierForCertificate_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (LoginResult, LoginResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = LoginResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loginWithVerifierForCertificate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecentMessages_args(object):
  """
  Attributes:
   - messageBoxId
   - messagesCount
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'messageBoxId', None, None, ), # 2
    (3, TType.I32, 'messagesCount', None, None, ), # 3
  )

  def __init__(self, messageBoxId=None, messagesCount=None,):
    self.messageBoxId = messageBoxId
    self.messagesCount = messagesCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.messageBoxId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.messagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecentMessages_args')
    if self.messageBoxId is not None:
      oprot.writeFieldBegin('messageBoxId', TType.STRING, 2)
      oprot.writeString(self.messageBoxId)
      oprot.writeFieldEnd()
    if self.messagesCount is not None:
      oprot.writeFieldBegin('messagesCount', TType.I32, 3)
      oprot.writeI32(self.messagesCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecentMessages_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Message, Message.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = Message()
            _elem79.read(iprot)
            self.success.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecentMessages_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter80 in self.success:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchMessages_args(object):
  """
  Attributes:
   - localTs
   - count
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I64, 'localTs', None, None, ), # 2
    (3, TType.I32, 'count', None, None, ), # 3
  )

  def __init__(self, localTs=None, count=None,):
    self.localTs = localTs
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I64:
          self.localTs = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchMessages_args')
    if self.localTs is not None:
      oprot.writeFieldBegin('localTs', TType.I64, 2)
      oprot.writeI64(self.localTs)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 3)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchMessages_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Message, Message.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype84, _size81) = iprot.readListBegin()
          for _i85 in xrange(_size81):
            _elem86 = Message()
            _elem86.read(iprot)
            self.success.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchMessages_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter87 in self.success:
        iter87.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchOperations_args(object):
  """
  Attributes:
   - localRev
   - count
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I64, 'localRev', None, None, ), # 2
    (3, TType.I32, 'count', None, None, ), # 3
  )

  def __init__(self, localRev=None, count=None,):
    self.localRev = localRev
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I64:
          self.localRev = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchOperations_args')
    if self.localRev is not None:
      oprot.writeFieldBegin('localRev', TType.I64, 2)
      oprot.writeI64(self.localRev)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 3)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchOperations_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Operation, Operation.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype91, _size88) = iprot.readListBegin()
          for _i92 in xrange(_size88):
            _elem93 = Operation()
            _elem93.read(iprot)
            self.success.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchOperations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter94 in self.success:
        iter94.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLastOpRevision_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLastOpRevision_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLastOpRevision_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLastOpRevision_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProfile_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProfile_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getProfile_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Profile, Profile.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Profile()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getProfile_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByMid_args(object):
  """
  Attributes:
   - reqSeq
   - mid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'mid', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, mid=None,):
    self.reqSeq = reqSeq
    self.mid = mid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByMid_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.mid is not None:
      oprot.writeFieldBegin('mid', TType.STRING, 2)
      oprot.writeString(self.mid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByMid_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype96, _vtype97, _size95 ) = iprot.readMapBegin()
          for _i99 in xrange(_size95):
            _key100 = iprot.readString();
            _val101 = Contact()
            _val101.read(iprot)
            self.success[_key100] = _val101
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByMid_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter102,viter103 in self.success.items():
        oprot.writeString(kiter102)
        viter103.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findContactByUserid_args(object):
  """
  Attributes:
   - userid
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'userid', None, None, ), # 2
  )

  def __init__(self, userid=None,):
    self.userid = userid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.userid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findContactByUserid_args')
    if self.userid is not None:
      oprot.writeFieldBegin('userid', TType.STRING, 2)
      oprot.writeString(self.userid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findContactByUserid_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Contact, Contact.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Contact()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findContactByUserid_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByUserid_args(object):
  """
  Attributes:
   - reqSeq
   - userid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'userid', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, userid=None,):
    self.reqSeq = reqSeq
    self.userid = userid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByUserid_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.userid is not None:
      oprot.writeFieldBegin('userid', TType.STRING, 2)
      oprot.writeString(self.userid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByUserid_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype105, _vtype106, _size104 ) = iprot.readMapBegin()
          for _i108 in xrange(_size104):
            _key109 = iprot.readString();
            _val110 = Contact()
            _val110.read(iprot)
            self.success[_key109] = _val110
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByUserid_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter111,viter112 in self.success.items():
        oprot.writeString(kiter111)
        viter112.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findContactsByPhone_args(object):
  """
  Attributes:
   - phones
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.SET, 'phones', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, phones=None,):
    self.phones = phones

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.SET:
          self.phones = set()
          (_etype116, _size113) = iprot.readSetBegin()
          for _i117 in xrange(_size113):
            _elem118 = iprot.readString();
            self.phones.add(_elem118)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findContactsByPhone_args')
    if self.phones is not None:
      oprot.writeFieldBegin('phones', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.phones))
      for iter119 in self.phones:
        oprot.writeString(iter119)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findContactsByPhone_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype121, _vtype122, _size120 ) = iprot.readMapBegin()
          for _i124 in xrange(_size120):
            _key125 = iprot.readString();
            _val126 = Contact()
            _val126.read(iprot)
            self.success[_key125] = _val126
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findContactsByPhone_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter127,viter128 in self.success.items():
        oprot.writeString(kiter127)
        viter128.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByPhone_args(object):
  """
  Attributes:
   - reqSeq
   - phones
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.SET, 'phones', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, reqSeq=None, phones=None,):
    self.reqSeq = reqSeq
    self.phones = phones

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.phones = set()
          (_etype132, _size129) = iprot.readSetBegin()
          for _i133 in xrange(_size129):
            _elem134 = iprot.readString();
            self.phones.add(_elem134)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByPhone_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.phones is not None:
      oprot.writeFieldBegin('phones', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.phones))
      for iter135 in self.phones:
        oprot.writeString(iter135)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByPhone_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin()
          for _i140 in xrange(_size136):
            _key141 = iprot.readString();
            _val142 = Contact()
            _val142.read(iprot)
            self.success[_key141] = _val142
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByPhone_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter143,viter144 in self.success.items():
        oprot.writeString(kiter143)
        viter144.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findContactsByEmail_args(object):
  """
  Attributes:
   - emails
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.SET, 'emails', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, emails=None,):
    self.emails = emails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.SET:
          self.emails = set()
          (_etype148, _size145) = iprot.readSetBegin()
          for _i149 in xrange(_size145):
            _elem150 = iprot.readString();
            self.emails.add(_elem150)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findContactsByEmail_args')
    if self.emails is not None:
      oprot.writeFieldBegin('emails', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.emails))
      for iter151 in self.emails:
        oprot.writeString(iter151)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findContactsByEmail_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype153, _vtype154, _size152 ) = iprot.readMapBegin()
          for _i156 in xrange(_size152):
            _key157 = iprot.readString();
            _val158 = Contact()
            _val158.read(iprot)
            self.success[_key157] = _val158
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findContactsByEmail_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter159,viter160 in self.success.items():
        oprot.writeString(kiter159)
        viter160.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByEmail_args(object):
  """
  Attributes:
   - reqSeq
   - emails
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.SET, 'emails', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, reqSeq=None, emails=None,):
    self.reqSeq = reqSeq
    self.emails = emails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.emails = set()
          (_etype164, _size161) = iprot.readSetBegin()
          for _i165 in xrange(_size161):
            _elem166 = iprot.readString();
            self.emails.add(_elem166)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByEmail_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.emails is not None:
      oprot.writeFieldBegin('emails', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.emails))
      for iter167 in self.emails:
        oprot.writeString(iter167)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAndAddContactsByEmail_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype169, _vtype170, _size168 ) = iprot.readMapBegin()
          for _i172 in xrange(_size168):
            _key173 = iprot.readString();
            _val174 = Contact()
            _val174.read(iprot)
            self.success[_key173] = _val174
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAndAddContactsByEmail_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter175,viter176 in self.success.items():
        oprot.writeString(kiter175)
        viter176.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContact_args(object):
  """
  Attributes:
   - id
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'id', None, None, ), # 2
  )

  def __init__(self, id=None,):
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContact_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContact_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Contact, Contact.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Contact()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContact_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContacts_args(object):
  """
  Attributes:
   - ids
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.LIST, 'ids', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, ids=None,):
    self.ids = ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.LIST:
          self.ids = []
          (_etype180, _size177) = iprot.readListBegin()
          for _i181 in xrange(_size177):
            _elem182 = iprot.readString();
            self.ids.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContacts_args')
    if self.ids is not None:
      oprot.writeFieldBegin('ids', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.ids))
      for iter183 in self.ids:
        oprot.writeString(iter183)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContacts_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Contact, Contact.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype187, _size184) = iprot.readListBegin()
          for _i188 in xrange(_size184):
            _elem189 = Contact()
            _elem189.read(iprot)
            self.success.append(_elem189)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContacts_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter190 in self.success:
        iter190.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllContactIds_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllContactIds_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllContactIds_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype194, _size191) = iprot.readListBegin()
          for _i195 in xrange(_size191):
            _elem196 = iprot.readString();
            self.success.append(_elem196)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllContactIds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter197 in self.success:
        oprot.writeString(iter197)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBlockedContactIds_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBlockedContactIds_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBlockedContactIds_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype201, _size198) = iprot.readListBegin()
          for _i202 in xrange(_size198):
            _elem203 = iprot.readString();
            self.success.append(_elem203)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBlockedContactIds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter204 in self.success:
        oprot.writeString(iter204)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class blockContact_args(object):
  """
  Attributes:
   - reqSeq
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'id', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, id=None,):
    self.reqSeq = reqSeq
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('blockContact_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class blockContact_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('blockContact_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unblockContact_args(object):
  """
  Attributes:
   - reqSeq
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'id', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, id=None,):
    self.reqSeq = reqSeq
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unblockContact_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unblockContact_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unblockContact_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createRoom_args(object):
  """
  Attributes:
   - reqSeq
   - contactIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.LIST, 'contactIds', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, reqSeq=None, contactIds=None,):
    self.reqSeq = reqSeq
    self.contactIds = contactIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.contactIds = []
          (_etype208, _size205) = iprot.readListBegin()
          for _i209 in xrange(_size205):
            _elem210 = iprot.readString();
            self.contactIds.append(_elem210)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createRoom_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.contactIds is not None:
      oprot.writeFieldBegin('contactIds', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.contactIds))
      for iter211 in self.contactIds:
        oprot.writeString(iter211)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createRoom_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Room, Room.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Room()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCompactRoom_args(object):
  """
  Attributes:
   - roomId
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'roomId', None, None, ), # 2
  )

  def __init__(self, roomId=None,):
    self.roomId = roomId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.roomId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCompactRoom_args')
    if self.roomId is not None:
      oprot.writeFieldBegin('roomId', TType.STRING, 2)
      oprot.writeString(self.roomId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCompactRoom_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Room, Room.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Room()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCompactRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRoom_args(object):
  """
  Attributes:
   - roomId
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'roomId', None, None, ), # 2
  )

  def __init__(self, roomId=None,):
    self.roomId = roomId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.roomId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRoom_args')
    if self.roomId is not None:
      oprot.writeFieldBegin('roomId', TType.STRING, 2)
      oprot.writeString(self.roomId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRoom_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Room, Room.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Room()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inviteIntoRoom_args(object):
  """
  Attributes:
   - reqSeq
   - roomId
   - contactIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'roomId', None, None, ), # 2
    (3, TType.LIST, 'contactIds', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, reqSeq=None, roomId=None, contactIds=None,):
    self.reqSeq = reqSeq
    self.roomId = roomId
    self.contactIds = contactIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.roomId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contactIds = []
          (_etype215, _size212) = iprot.readListBegin()
          for _i216 in xrange(_size212):
            _elem217 = iprot.readString();
            self.contactIds.append(_elem217)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inviteIntoRoom_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.roomId is not None:
      oprot.writeFieldBegin('roomId', TType.STRING, 2)
      oprot.writeString(self.roomId)
      oprot.writeFieldEnd()
    if self.contactIds is not None:
      oprot.writeFieldBegin('contactIds', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contactIds))
      for iter218 in self.contactIds:
        oprot.writeString(iter218)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inviteIntoRoom_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inviteIntoRoom_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class leaveRoom_args(object):
  """
  Attributes:
   - reqSeq
   - roomId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'roomId', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, roomId=None,):
    self.reqSeq = reqSeq
    self.roomId = roomId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.roomId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('leaveRoom_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.roomId is not None:
      oprot.writeFieldBegin('roomId', TType.STRING, 2)
      oprot.writeString(self.roomId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class leaveRoom_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('leaveRoom_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createGroup_args(object):
  """
  Attributes:
   - seq
   - name
   - contactIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'seq', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.LIST, 'contactIds', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, seq=None, name=None, contactIds=None,):
    self.seq = seq
    self.name = name
    self.contactIds = contactIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.seq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contactIds = []
          (_etype222, _size219) = iprot.readListBegin()
          for _i223 in xrange(_size219):
            _elem224 = iprot.readString();
            self.contactIds.append(_elem224)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createGroup_args')
    if self.seq is not None:
      oprot.writeFieldBegin('seq', TType.I32, 1)
      oprot.writeI32(self.seq)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.contactIds is not None:
      oprot.writeFieldBegin('contactIds', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contactIds))
      for iter225 in self.contactIds:
        oprot.writeString(iter225)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createGroup_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Group, Group.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Group()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCompactGroup_args(object):
  """
  Attributes:
   - groupId
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
  )

  def __init__(self, groupId=None,):
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCompactGroup_args')
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCompactGroup_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Group, Group.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Group()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCompactGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroups_args(object):
  """
  Attributes:
   - groupIds
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.LIST, 'groupIds', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, groupIds=None,):
    self.groupIds = groupIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.LIST:
          self.groupIds = []
          (_etype229, _size226) = iprot.readListBegin()
          for _i230 in xrange(_size226):
            _elem231 = iprot.readString();
            self.groupIds.append(_elem231)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroups_args')
    if self.groupIds is not None:
      oprot.writeFieldBegin('groupIds', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.groupIds))
      for iter232 in self.groupIds:
        oprot.writeString(iter232)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroups_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Group, Group.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype236, _size233) = iprot.readListBegin()
          for _i237 in xrange(_size233):
            _elem238 = Group()
            _elem238.read(iprot)
            self.success.append(_elem238)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter239 in self.success:
        iter239.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupIdsInvited_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupIdsInvited_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupIdsInvited_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype243, _size240) = iprot.readListBegin()
          for _i244 in xrange(_size240):
            _elem245 = iprot.readString();
            self.success.append(_elem245)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupIdsInvited_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter246 in self.success:
        oprot.writeString(iter246)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupIdsJoined_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupIdsJoined_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupIdsJoined_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype250, _size247) = iprot.readListBegin()
          for _i251 in xrange(_size247):
            _elem252 = iprot.readString();
            self.success.append(_elem252)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupIdsJoined_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter253 in self.success:
        oprot.writeString(iter253)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inviteIntoGroup_args(object):
  """
  Attributes:
   - reqSeq
   - groupId
   - contactIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
    (3, TType.LIST, 'contactIds', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, reqSeq=None, groupId=None, contactIds=None,):
    self.reqSeq = reqSeq
    self.groupId = groupId
    self.contactIds = contactIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contactIds = []
          (_etype257, _size254) = iprot.readListBegin()
          for _i258 in xrange(_size254):
            _elem259 = iprot.readString();
            self.contactIds.append(_elem259)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inviteIntoGroup_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    if self.contactIds is not None:
      oprot.writeFieldBegin('contactIds', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contactIds))
      for iter260 in self.contactIds:
        oprot.writeString(iter260)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inviteIntoGroup_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inviteIntoGroup_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class kickoutFromGroup_args(object):
  """
  Attributes:
   - reqSeq
   - groupId
   - contactIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
    (3, TType.LIST, 'contactIds', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, reqSeq=None, groupId=None, contactIds=None,):
    self.reqSeq = reqSeq
    self.groupId = groupId
    self.contactIds = contactIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contactIds = []
          (_etype264, _size261) = iprot.readListBegin()
          for _i265 in xrange(_size261):
            _elem266 = iprot.readString();
            self.contactIds.append(_elem266)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('kickoutFromGroup_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    if self.contactIds is not None:
      oprot.writeFieldBegin('contactIds', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contactIds))
      for iter267 in self.contactIds:
        oprot.writeString(iter267)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class kickoutFromGroup_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('kickoutFromGroup_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acceptGroupInvitation_args(object):
  """
  Attributes:
   - reqSeq
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, groupId=None,):
    self.reqSeq = reqSeq
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acceptGroupInvitation_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acceptGroupInvitation_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acceptGroupInvitation_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancelGroupInvitation_args(object):
  """
  Attributes:
   - reqSeq
   - groupId
   - contactIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
    (3, TType.LIST, 'contactIds', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, reqSeq=None, groupId=None, contactIds=None,):
    self.reqSeq = reqSeq
    self.groupId = groupId
    self.contactIds = contactIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.contactIds = []
          (_etype271, _size268) = iprot.readListBegin()
          for _i272 in xrange(_size268):
            _elem273 = iprot.readString();
            self.contactIds.append(_elem273)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancelGroupInvitation_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    if self.contactIds is not None:
      oprot.writeFieldBegin('contactIds', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.contactIds))
      for iter274 in self.contactIds:
        oprot.writeString(iter274)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancelGroupInvitation_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancelGroupInvitation_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class leaveGroup_args(object):
  """
  Attributes:
   - reqSeq
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reqSeq', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
  )

  def __init__(self, reqSeq=None, groupId=None,):
    self.reqSeq = reqSeq
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reqSeq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('leaveGroup_args')
    if self.reqSeq is not None:
      oprot.writeFieldBegin('reqSeq', TType.I32, 1)
      oprot.writeI32(self.reqSeq)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class leaveGroup_result(object):
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('leaveGroup_result')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBox_args(object):
  """
  Attributes:
   - channelId
   - messageBoxId
   - lastMessagesCount
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.STRING, 'messageBoxId', None, None, ), # 3
    (4, TType.I32, 'lastMessagesCount', None, None, ), # 4
  )

  def __init__(self, channelId=None, messageBoxId=None, lastMessagesCount=None,):
    self.channelId = channelId
    self.messageBoxId = messageBoxId
    self.lastMessagesCount = lastMessagesCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.messageBoxId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.lastMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBox_args')
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.messageBoxId is not None:
      oprot.writeFieldBegin('messageBoxId', TType.STRING, 3)
      oprot.writeString(self.messageBoxId)
      oprot.writeFieldEnd()
    if self.lastMessagesCount is not None:
      oprot.writeFieldBegin('lastMessagesCount', TType.I32, 4)
      oprot.writeI32(self.lastMessagesCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBox_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MessageBox, MessageBox.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MessageBox()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBox_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxList_args(object):
  """
  Attributes:
   - channelId
   - lastMessagesCount
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.I32, 'lastMessagesCount', None, None, ), # 3
  )

  def __init__(self, channelId=None, lastMessagesCount=None,):
    self.channelId = channelId
    self.lastMessagesCount = lastMessagesCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.lastMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxList_args')
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.lastMessagesCount is not None:
      oprot.writeFieldBegin('lastMessagesCount', TType.I32, 3)
      oprot.writeI32(self.lastMessagesCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxList_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(MessageBox, MessageBox.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype278, _size275) = iprot.readListBegin()
          for _i279 in xrange(_size275):
            _elem280 = MessageBox()
            _elem280.read(iprot)
            self.success.append(_elem280)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter281 in self.success:
        iter281.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxListByStatus_args(object):
  """
  Attributes:
   - channelId
   - lastMessagesCount
   - status
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.I32, 'lastMessagesCount', None, None, ), # 3
    (4, TType.I32, 'status', None, None, ), # 4
  )

  def __init__(self, channelId=None, lastMessagesCount=None, status=None,):
    self.channelId = channelId
    self.lastMessagesCount = lastMessagesCount
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.lastMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxListByStatus_args')
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.lastMessagesCount is not None:
      oprot.writeFieldBegin('lastMessagesCount', TType.I32, 3)
      oprot.writeI32(self.lastMessagesCount)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxListByStatus_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(MessageBox, MessageBox.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype285, _size282) = iprot.readListBegin()
          for _i286 in xrange(_size282):
            _elem287 = MessageBox()
            _elem287.read(iprot)
            self.success.append(_elem287)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxListByStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter288 in self.success:
        iter288.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxCompactWrapUp_args(object):
  """
  Attributes:
   - mid
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'mid', None, None, ), # 2
  )

  def __init__(self, mid=None,):
    self.mid = mid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.mid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxCompactWrapUp_args')
    if self.mid is not None:
      oprot.writeFieldBegin('mid', TType.STRING, 2)
      oprot.writeString(self.mid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxCompactWrapUp_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MessageBoxWrapUp, MessageBoxWrapUp.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MessageBoxWrapUp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxCompactWrapUp_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxCompactWrapUpList_args(object):
  """
  Attributes:
   - start
   - messageBoxCount
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I32, 'start', None, None, ), # 2
    (3, TType.I32, 'messageBoxCount', None, None, ), # 3
  )

  def __init__(self, start=None, messageBoxCount=None,):
    self.start = start
    self.messageBoxCount = messageBoxCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I32:
          self.start = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.messageBoxCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxCompactWrapUpList_args')
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I32, 2)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.messageBoxCount is not None:
      oprot.writeFieldBegin('messageBoxCount', TType.I32, 3)
      oprot.writeI32(self.messageBoxCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageBoxCompactWrapUpList_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MessageBoxWrapUpResponse, MessageBoxWrapUpResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MessageBoxWrapUpResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageBoxCompactWrapUpList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendMessage_args(object):
  """
  Attributes:
   - seq
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'seq', None, None, ), # 1
    (2, TType.STRUCT, 'message', (Message, Message.thrift_spec), None, ), # 2
  )

  def __init__(self, seq=None, message=None,):
    self.seq = seq
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.seq = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.message = Message()
          self.message.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendMessage_args')
    if self.seq is not None:
      oprot.writeFieldBegin('seq', TType.I32, 1)
      oprot.writeI32(self.seq)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRUCT, 2)
      self.message.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendMessage_result(object):
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Message, Message.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (TalkException, TalkException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Message()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = TalkException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendMessage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
